---
title: "Mini Proyecto Tratamiento de Datos"
author: "Grupo I"
date: "2025-04-12"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```
## Introducción
Hoy en día, el análisis de datos se ha convertido en una herramienta muy 
poderosa para la toma de decisiones. A través de la recolección, procesamiento
y utilización de datos, las empresas pueden obtener ventajas económicas y 
estrategias.

En nuestro caso, enfocamos el proyecto en:
- Crear un dataset con los datos de cada uno de los tickets despues de haberlos
organizado de manera que sean entendibles y nos ayuden a contestar las 
preguntas que nos hacemos acerca de ellos


Para conseguirlo, partimos de un conjunto de tickets de supermercados en formato 
PDF, los cuales transformaremos a un formato estructurado(data frame). 

```{r}
library(pdftools)
library(dplyr)
library(stringr)

# Listar todos los PDFs con "Mercadona" en el nombre dentro de la carpeta 'data', así mismo, devuelve un vector con las rutas completas de archivos que cumplen las condiciones de filtrado.
ficheros <- list.files(path = "data", pattern = "Mercadona", full.names = TRUE)

extraer_productos_unitarios <- function(lineas_productos) {
  productos <- data.frame(stringsAsFactors = FALSE)
  
  for (linea in lineas_productos) {
    linea <- trimws(linea)
    
    # Caso con precio unitario y total (ej: "2 PRODUCTO 1,60 3,20")
    if (str_detect(linea, "^\\d+\\s+.+\\s+\\d+,\\d{2}\\s+\\d+,\\d{2}$")) {
      matched <- str_match(linea, "^(\\d+)\\s+(.+?)\\s+(\\d+,\\d{2})\\s+(\\d+,\\d{2})$")
      cantidad_orig <- matched[2]
      producto_nom  <- matched[3]
      pu_orig       <- matched[4]
      imp           <- matched[5]
      # si la cantidad es 1, el precio_unitario es el propio importe
      precio_unit   <- if (cantidad_orig == "1") imp else pu_orig
      fila <- data.frame(
        cantidad        = cantidad_orig,
        producto        = producto_nom,
        precio_unitario = precio_unit,
        importe         = imp,
        tipo            = "Unitario",
        stringsAsFactors = FALSE
      )
      productos <- rbind(productos, fila)
      
    # Caso solo con importe final (ej: "1 PRODUCTO 1,55")
    } else if (str_detect(linea, "^\\d+\\s+.+\\s+\\d+,\\d{2}$")) {
      matched <- str_match(linea, "^(\\d+)\\s+(.+?)\\s+(\\d+,\\d{2})$")
      fila <- data.frame(
        cantidad        = matched[2],
        producto        = matched[3],
        precio_unitario = matched[4],  # igual al importe cuando cantidad == 1
        importe         = matched[4],
        tipo            = "Unitario",
        stringsAsFactors = FALSE
      )
      productos <- rbind(productos, fila)
    }
  }
  
  return(productos)
}

# Nueva función para extraer productos por peso (ej: "1,200 kg 3,50 €/kg 4,20")
extraer_productos_peso <- function(lineas_productos) {
  productos <- data.frame(stringsAsFactors = FALSE)
  
  for (i in seq_along(lineas_productos)) {
    # línea con precio por kg
    if (str_detect(lineas_productos[i], "[0-9,]+\\s*kg")) {
      # nombre en la línea anterior, sin prefijo numérico si existe
      nombre <- str_trim(str_remove(lineas_productos[i-1], "^\\d+\\s+"))
      matched <- str_match(lineas_productos[i], "([0-9,]+)\\s*kg\\s*([0-9,]+)\\s*€/kg\\s*([0-9,]+)")
      fila <- data.frame(
        cantidad        = matched[2],
        producto        = nombre,
        precio_unitario = matched[3],
        importe         = matched[4],
        tipo            = "Peso",
        stringsAsFactors = FALSE
      )
      productos <- rbind(productos, fila)
    }
  }
  
  return(productos)
}

# Definimos una funcion
ticket_lines_offset <- 8  # línea donde empiezan los productos
leer_ticket <- function(x) {
  data <- pdf_text(x) # Leemos todo el texto de los pdfs filtrados
  
  lineas <- strsplit(data, "\n")[[1]] # Strsplit para separar el texto en lineas
  lineas <- lineas[nchar(trimws(lineas)) > 0]  # limpiamos líneas vacías
  
  direccion <- trimws(lineas[2])
  
  linea3 <- trimws(lineas[3])
  cp <- substr(linea3, 1, 5)
  ciudad <- substr(linea3, 7, nchar(linea3))
  
  telefono <- substr(trimws(lineas[4]), 11, nchar(lineas[4]))
  
  linea_fecha_hora_op <- lineas[grep("OP:", lineas)[1]]  # Busca la línea con "OP:"
  fecha_hora_op <- strsplit(trimws(linea_fecha_hora_op), "\\s+")[[1]] 
  #Usamos strsplit para dividir esa línea por espacios y extraer
  # los elementos en posiciones fijas
  
  fecha <- fecha_hora_op[1]  # fecha
  hora <- fecha_hora_op[2]   # hora
  operario <- fecha_hora_op[4]  # número de operario
  
  linea_factura <- lineas[grep("FACTURA SIMPLIFICADA:", lineas)[1]]
  factura_completa <- trimws(sub(".*FACTURA SIMPLIFICADA:", "", linea_factura))
  partes_factura <- strsplit(factura_completa, "-")[[1]]  # Dividir por "-"
  
  # Asignar partes (si existen)
  num_tienda <- ifelse(length(partes_factura) >= 1, partes_factura[1], NA)
  num_caja <- ifelse(length(partes_factura) >= 2, partes_factura[2], NA)
  num_ticket <- ifelse(length(partes_factura) >= 3, partes_factura[3], NA)
  
  # Extracción de productos 
  linea_fin <- grep("ENTRADA|TOTAL", lineas, ignore.case = TRUE)
  lineas_productos <- lineas[ticket_lines_offset:(linea_fin[1]-1)]
  productos_unitarios <- extraer_productos_unitarios(lineas_productos)
  productos_peso      <- extraer_productos_peso(lineas_productos)
  productos <- rbind(productos_unitarios, productos_peso)
  
  # Total de la compra:
  linea_total <- grep("TOTAL", lineas)
  total_lista <- strsplit(lineas[linea_total[1]], " {2,}")
  total_compra <- total_lista[[1]][3]
  
  # Añadir metadatos a cada producto
  if (nrow(productos) > 0) {
    productos$fichero <- basename(x)
    productos$fecha <- fecha
    productos$hora <- hora
    productos$direccion <- direccion
    productos$cp <- cp
    productos$ciudad <- ciudad
    productos$telefono <- telefono
    productos$operario <- operario
    productos$factura_completa <- factura_completa
    productos$num_tienda <- num_tienda
    productos$num_caja <- num_caja
    productos$num_ticket <- num_ticket
    productos$total_compra <- total_compra
  }
  
  return(productos)
}

# Procesar todos los tickets
df_tickets <- do.call(rbind, lapply(ficheros, leer_ticket))
# View y export
View(df_tickets)
write.csv(df_tickets, "df_tickets.csv", row.names = FALSE)

```

Hemos leído los tickets de supermercado usando `pdf_text()` y transformado su contenido en un `data.frame`.
La siguiente tabla muestra un ejemplo del contenido:

```{r tablauno, echo = FALSE}
knitr::kable(head(df_tickets, 15), caption = "**TABLA 1. Datos importados.**")
```

En la tabla 1 podemos ver la forma en la que hemos importado la información de los tickets. Cada 
fila del `data.frame` se corresponde con una línea del ticket especificado en la variable fichero. 
Tenemos todas las líneas de cada ticket, lo cual nos permitirá disponer de la máxima información posible.

## Preguntas

Tras realizar la importación de los datos y observar la información que nos 
aportan los tickets, nos planteamos una serie de preguntas:

- ¿Cuántos productos suele incluir un ticket promedio? ¿Y el importe promedio por ticket?

```{r}
# Agrupamos por ticket y calculamos número de líneas (productos) y total del importe

resumen <- df_tickets %>%
  group_by(fichero) %>%
  summarise(
    productos_ticket = n(),
    importe_ticket   = sum(as.numeric(gsub(",", ".", importe)), na.rm = TRUE)
  )

# Calculamos la media 

media_productos <- mean(resumen$productos_ticket)
media_importe   <- mean(resumen$importe_ticket)

paste("productos medios por ticket",round(media_productos, 2))
paste("importe medio por ticket", round(media_importe, 2))

# Por tanto vemos que normalmente hay una media de 17 productos por ticket 
# Y el importe medio suele ser unos 46 euros 

```

- ¿Las tiendas en ciudades grandes (como Valencia) tienen tickets con importes más altos que las de pueblos pequeños?
```{r}

#  Calcular importe total por ticket
 res_ticket <- df_tickets %>%
  group_by(ciudad, fichero) %>%
  summarise(
    importe_ticket = sum(as.numeric(gsub(",", ".", importe))),
    .groups = "drop"
  )

#  Calcular importe medio por ciudad
media_importe_ciudad <- res_ticket %>%
  group_by(ciudad) %>%
  summarise(
    media_importe = mean(importe_ticket),
    .groups = "drop"
  ) %>%
  arrange(desc(media_importe))

# Mostrar la tabla de importes medios por ciudad
print(media_importe_ciudad)

# Como podemos ver resulta que valencia no esta ni en la primera pagina de los 
#resultados, las poblaciones que más gastan son las de tamaño medio/pequeño

```

- ¿Cuál es el producto más caro vendido por unidades? ¿Y el más barato?

```{r}
#Filtrar sólo productos unitarios y convertimos el precio a valor numerico

tabla_precios <- df_tickets %>%
  filter(tipo == "Unitario") %>%  
  mutate(
    precio_num = as.numeric(gsub(",", ".", precio_unitario))
  ) %>%
  filter(precio_num > 0) %>%     # ignorar valores cero
  select(producto, precio_num)

# Usamos unique para que solo aparezca cada elemento una vez 

tabla_precios <- unique(tabla_precios)

# Tablas primero en orden ascendente y luego descente para ver cual es el producto mas caro y mas barato
tabla_asc <- tabla_precios %>%
  arrange(precio_num)

tabla_desc <- tabla_precios %>%
  arrange(desc(precio_num))

#Mostramos tablas

tabla_asc
tabla_desc

```

- ¿Cúal ha sido la compra de mayor importe? ¿Y la de menor importe?
```{r}
# Sumar importe por ticket
extremos <- df_tickets %>%
  group_by(fichero) %>%
  summarise(
    importe_ticket = sum(as.numeric(gsub(",", ".", importe)), na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(importe_ticket)

# Sacamos el minimo y maximo 
compra_menor <- extremos %>% slice(1)
compra_mayor <- extremos %>% slice(n())

#mostramos el valor de la compra mas grande y mas pequeña
cat("La compra de menor importe tiene un valor de ", 
    round(compra_menor$importe_ticket, 2), "€\n", sep = "")
cat("La compra de mayor importe tiene un valor de ", 
    round(compra_mayor$importe_ticket, 2), "€\n", sep = "")


```

- ¿A qué horas del día se realizan más compras?

```{r}
library(ggplot2) 

horas_compras <- df_tickets %>%
  # Seleccionar solo columnas relevantes
  select(fecha, hora) %>%
  # Extraer solo la hora (sin minutos)
  mutate(hora_simple = substr(hora, 1, 2)) %>%
  # Contar compras por hora
  count(hora_simple) %>%
  # Ordenar de mayor a menor frecuencia
  arrange(desc(n)) %>%
  # Renombrar columnas para claridad
  rename(hora = hora_simple, compras = n)

# Ver el resultado
View(horas_compras)

# Opcional: gráfico de barras
ggplot(horas_compras, aes(x = hora, y = compras)) +
  geom_col(fill = "red") +
  labs(title = "Cantidad de compras por hora en un dia",
       x = "Hora",
       y = "Cantidad de compras") +
  theme_minimal()

#Como se puede observar en la grafica, se realiza un mayor numero de compras en las horas de la tarde. A las 20h se vende un total de 1827 productos, siendo el numero mas alto
```


- Realizar un gráfico de las diferentes localidades en función del dinero ingresado 
en cada una de ellas, de mayor a menor.

```{r}
library(dplyr)
dinero_localidades <- df_tickets%>%
  
  # Convertir total_compra a numérico (reemplazando coma por punto)
  mutate(total_compra = as.numeric(gsub(",", ".", total_compra))) %>%
  
  # Agrupar por localidad (ciudad)
  group_by(ciudad) %>%
  
  # Calcular el total ingresado por localidad
  summarise(total_ingresado = sum(total_compra, na.rm = TRUE)) %>%
  
  # Ordenar de mayor a menor
  arrange(desc(total_ingresado))%>%
  
 mutate(ciudad_ordenada = reorder(ciudad, -total_ingresado))%>% #Reorder: reordena los niveles de un factor. El signo "-", indica que será descendente
  
  slice_max(total_ingresado, n=15) %>%  #Solo salen las 15 primeras ciudades
  
  filter(!is.na(total_ingresado)) #Filtramos los NA

  # Gráfico de barras
ggplot(dinero_localidades, aes(x= ciudad_ordenada, y = total_ingresado))+ geom_col(fill = 'skyblue')+ labs(title = "Dinero ganado por localidades", x = "Ciudades", y = "Ingresos")+ theme_minimal() + theme(axis.text.x = element_text(angle = 45, hjust = 1))
                   #Sirve para rotar las etiquetas y que quepan en el grafico

# La localidad con más ingresos es Valencia, con 113220 € ingresados.
#A esta le sigue Alcoy con 77768 € y Muro de Alcoy que baja a 30277€
```


- ¿Cuáles son los productos menos vendidos de los que se venden por unidades? 
¿Y de los que se venden al peso?

También trataremos de responder a las preguntas que nos plantean en el proyecto, 
que son las siguientes:

- ¿Cuáles son los 5 productos, de los vendidos por unidades, con más ventas? 
¿Cuántas unidades de cada uno se han vendido?

```{r}
Ventas_unitarias <- df_tickets %>% filter(tipo == "Unitario") %>% 
  
  group_by(producto) %>%
  
  summarise(Unidades_vendidas = sum(as.numeric(cantidad))) %>%
  
  arrange(desc(Unidades_vendidas)) %>% 
  
  slice_max(Unidades_vendidas, n=15)

ggplot(Ventas_unitarias, aes(x = reorder(producto, Unidades_vendidas, decreasing = TRUE), y = Unidades_vendidas)) + 
  geom_col(fill = "forestgreen")  +
  theme(axis.text.x = element_text(angle = 54, hjust = 1)) + 
  labs(title = "Productos más vendidos. (Solo productos vendidos por unidades)", x = "Producto", y = "Unidades vendidas", caption = "Los 5 productos más vendidos son: Atún claro oliva, con 62 unidades,\nqueso lonchas cabra con 53, bolsa plastico con 51, leche desnat. calcio con 49 y yogur coco con 40")
```


- Si consideramos la categoría de FRUTAS Y VERDURAS. 
Cuáles son los 5 productos más vendidos? ¿Cuántos kilos se han vendido de cada uno de estos productos?

- Si consideramos la categoría de PESCADO. 
Cuáles son los 5 productos más vendidos? ¿Cuántos kilos se han vendido de cada uno de estos productos?

```{r}
library(dplyr)
library(stringr)
library(ggplot2)

# 1. Filtrar productos de pescado 
top_pescados <- df_tickets %>%
  filter(
    tipo == "Peso",  # Solo productos vendidos por peso
    str_detect(tolower(producto), "pescado|merluza|salmón|atún|bacalao|dorada|sardina|bogavante")  # Palabras clave de pescado
  ) %>%
  mutate(
    cantidad_kg = as.numeric(str_replace(cantidad, ",", "."))  # Convertimos kilos a numérico
  ) %>%
  
  mutate(
  producto_limpio = case_when(
    str_detect(tolower(producto), "dorada") ~ "DORADA",  # Agrupa cualquier producto que contenga "dorada"
    str_detect(tolower(producto), "bacalao") ~ "BACALAO",  # Agrupa cualquier producto que contenga "bacalao"
    str_detect(tolower(producto), "sardina") ~ "SARDINA",
    str_detect(tolower(producto), "dorada") ~ "DORADA",
    str_detect(tolower(producto), "atun") ~ "ATUN",
    str_detect(tolower(producto), "bogavante") ~ "BOGAVANTE",
    str_detect(tolower(producto), "merluza") ~ "MERLUZA",
    TRUE ~ producto  # El resto de productos se quedan igual
  )
) %>%
  
  group_by(producto_limpio) %>%  # Agrupamos por nombre de producto limpio
  summarise(
    kilos_vendidos = sum(cantidad_kg, na.rm = TRUE),  # Sumamos kilos por producto
    veces_vendido = n()  # Contar número de ventas
  ) %>%
  arrange(desc(kilos_vendidos)) %>%  # de mayor a menor

# Mostrar resultado
print(top_pescados)

library(ggplot2)
ggplot(top_pescados, aes(x = reorder(producto_limpio, -kilos_vendidos), y = kilos_vendidos)) +
  geom_col(fill = "darkcyan") +
  labs(
    title = "Top 4 productos de pescado más vendidos (en kilos)",
    x = "Producto",
    y = "Kilos vendidos"
  ) +
  theme_minimal()

#Los 4 productos de pescado más vendidos son la dorada con casi 3 kilos, el bacalao, la merluza y  la sardina 
```



- Muestra mediante un gráfico de líneas como ha variado el precio por kilo de 
las bananas y los plátanos en los tickets disponibles, a lo largo del tiempo.

```{r}
  
library(stringr)
library(lubridate)
library(dplyr)
library(ggplot2)

precio_kilo <- df_tickets %>%
   # Filtrar solo productos de tipo "Peso" que contengan "banana" o "plátano" en el nombre
  filter(tipo == "Peso" ) %>%
  
   mutate(precio_kg = as.numeric(str_replace(precio_unitario, ",", ".")),#Convertimos a numerico precio_unitario y reemplazamos comas por puntos
          
    # Convertir fecha a formato Date
    fecha = dmy(fecha),
  
    tipo_producto = case_when(
  str_detect(tolower(producto), "banana") ~ "Banana",
  str_detect(tolower(producto), "plátano|platano|plátano canario|plátano macho|platanos") ~ "Plátano",  
  TRUE ~ "Otro" ,   #Creamos una columna nueva que para clasificar los productos en dos categorías: "Banana" y "Plátano". Estanadarizamos los nombres en dos categorias               
  )) %>%      

    group_by(fecha, tipo_producto)%>%
  
    summarise(precio_medio = mean(precio_kg, na.rm=TRUE)) %>%  
  # Agrupar por fecha y tipo de producto para calcular precio medio

  # Filtrar solo bananas y plátanos
    filter(tipo_producto %in% c("Banana", "Plátano")) 

print(precio_kilo)

ggplot(precio_kilo, aes(x = fecha, y = precio_medio, color=tipo_producto)) + geom_line(size = 1) + geom_point(size = 2) + labs(title = "Variación del precio por kilo en bananas y plátanos", x="Fecha", y="Precio Medio") + theme_minimal() +  scale_color_manual(values = c("Banana" = "yellow", "Plátano" = "green"))


#Como podemos ver en el gráfico, el precio del plátano varia mucho de precio en comparación con la banana. Además, el plátano es bastante más caro.
```


- ¿Cuál es la procedencia de los tickets? ¿Qué ciudad/ pueblo tiene un mayor número de tickets?

```{r}
library(dplyr)
library(ggplot2)

# 1. Procedencia de los tickets (distribución por ciudad)
procedencia_tickets <- df_tickets %>%
  
  distinct(fichero, ciudad) %>%  # Para obtener una entrada única por ticket (evitando duplicados si un ticket tiene múltiples productos).

  count(ciudad, name = "num_tickets") %>% #Agrupamos por ciudad y contamos los tickets
  
  arrange(desc(num_tickets)) #Orden descendente

# Gráfico de procedencia     
ggplot(procedencia_tickets, aes(x = reorder(ciudad, -num_tickets), y = num_tickets)) +
  geom_col(fill = "orange") +
  labs(title = "Procedencia de los tickets por ciudad",
       x = "Ciudad",
       y = "Número de tickets") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) #Ajustamos el angulo de las etiquetas

# 2. Ciudad con mayor número de tickets (respuesta directa)
ciudad_mas_tickets <- procedencia_tickets %>%
  slice_max(num_tickets, n = 1)  #Seleccionamos la fila con el maximo valor en num_tickets
ciudad_mas_tickets

#La ciudad con más tickets es Valencia, con 129 tickets
```


- Muestra mediante un diagrama el número de tickets recogidos cada día de las semana. 
¿Si tuvieses que cerrar un día entre semana qué día lo harías ?

```{r}
Tickets_dia_semana <- df_tickets %>% mutate(dia_semana = weekdays(as.Date(fecha, format = "%d/%m/%Y"))) %>% #Transformo a Date la columna fecha y con weekdays obtengo el día de la semana que se corresponde con cada fecha, y con eso creo la variable dia_semana
  
  group_by(dia_semana) %>% 
  
  summarise(Tickets = n_distinct(fichero)) #Cuento los distintos ficheros que hay para cada día de la semana

ggplot(Tickets_dia_semana, aes(x = reorder(dia_semana, Tickets, decreasing = TRUE), y = Tickets)) + 
  geom_col(fill = "slateblue") + 
  labs(title = "Número de tickets recogidos cada día de la semana", x = "Día de la semana", caption = "Si tuviera que cerrar un día entre semana, lo haría el jueves.")

```

